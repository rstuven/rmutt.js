_ = require 'lodash'
jsStringEscape = require 'js-string-escape'
runtime = require './runtime'
parse = require './parse'
product = require '../package.json'
push = Array.prototype.push

###
# transpile
###
module.exports = (input, config) ->
  config ?= {}
  if typeof input is 'string'
    rules = parse input, config
  else
    rules = input
  result = transpile rules, config
  # console.log result
  result

transpile = (rules, config) ->
  # console.dir rules, colors: true, depth:10
  result = []

  # header
  result.push '// Generated by ', product.name, ' ', product.version, '\n'
  result.push '// ', config.header, '\n' if config.header?

  # exportable
  result.push 'module.exports = function($config) {\n'

  # fallback
  result.push '$config = $config || {};\n'

  # runtime
  _.each runtime, (fn, name) ->
    result.push 'var $', name , ' = (', fn.toString(), ')();\n'

  # global scope
  result.push 'var $global = {};\n\n'
  _.each rules, (rule, name) ->
    return if name is '$entry'
    push.apply result, concat [
      "$global['#{name}'] = "
      generateRuleDefinition rule
      ';\n\n'
    ]

  # kick off
  entry = config.entry ? rules.$entry
  if entry?
    result.push "return $global[$config.entry || '#{entry}']();\n"
  else
    result.push "if ($config.entry != null) return $global[$config.entry]();\n"

  # done!
  result.push '};'

  result.join ''

# TODO: Study extensibility model for composable externals
composable = ['Mapping']

types =

  # DEVNOTE: In alphabetical order

  Assignment: (rule) ->
    generateAssignment rule, generateRule rule.expr

  Choice: (rule) ->

    # Simplify single choice
    if rule.items.length is 1 and rule.items[0].type isnt 'Multiplied'
      return generateRule rule.items[0]

    lazyRules = pushJoin ', ', rule.items.map (rule) ->
      return "''" if not rule?
      if rule.type is 'Multiplied'
        multiplied = Array rule.multiplier
        _.fill multiplied, generateRule rule.expr, true
        pushJoin ', ', multiplied
      else
        generateRule rule, true

    concat [
      '$choice('
      lazyRules
      ')'
    ]

  Invocation: (rule, lazy) ->
    args = rule.args?
    concat [
      's.invoke'
      if lazy then 'Lazy'
      "('#{rule.name}'"
      if args then ', ['
      if args then generateRules rule.args
      if args then ']'
      ')'
    ]

  Multiplied: (rule) ->
    # Ignore rule.multiplier (parsed at this level for backward compatibility).
    # See it in action in Choice type.
    generateRule rule.expr

  Mapping: (rule) ->
    concat [
      '$mapping('
      generateRule rule.search
      ', '
      generateRule rule.replace, true
      ')'
    ]

  Repetition: (rule) ->
    concat [
      '$repeat('
      generateRule rule.expr, true
      ', '
      JSON.stringify rule.range
      ')'
    ]

  Rule: (rule) ->
    generateAssignment rule, generateRuleDefinition rule

  Terms: (rule) ->

    # Simplify single term
    if rule.items.length is 1
      return generateRule rule.items[0]

    fn =  if _.all(rule.items, (item) -> item.type in composable)
      '$compose'
    else
      '$concat'
    concat [
      fn
      '('
      generateRules rule.items
      ')'
    ]

  Transformation: (rule) ->
    # for transformation chaining, we need to make the tree left-recursive
    if rule.type is 'Transformation' and rule.func.type is 'Transformation'
      rule = makeTreeLeftRecursive rule, 'Transformation', 'expr', 'func'

    concat [
      '$transform('
      generateRule rule.expr
      ', '
      generateRule rule.func
      ')'
    ]

concat = (values) ->
  values.reduce (ret, value) ->
    ret.concat value
  , []

generateAssignment = (rule, generated) ->
  scope = switch rule.scope
    when 'local' then 'l'
    when 'parent' then '^'
    else 'g'

  concat [
    "s.assign('#{scope}', '#{rule.name}', "
    generated
    ')'
  ]

generateRule = (rule, lazy) ->
  return stringify '' unless rule?
  return stringify rule if typeof rule is 'string'
  unless types[rule.type]?
    throw new Error 'No transpilation defined for rule type: ' + rule.type
  generated = types[rule.type] rule, lazy
  if lazy and rule.type isnt 'Invocation'
    concat [
      'function () { return '
      generated
      '}'
    ]
  else
    generated

generateRuleDefinition = (rule) ->
  concat [
    '$rule(function rule__'
    rule.name.replace(/-/g, '_').replace(/\./g, '__')
    '(s) { \n'
    'return '
    generateRule rule.expr
    ';\n}'
    if rule.args? then ', ' + JSON.stringify rule.args
    ')'
  ]

generateRules = (rules) ->
  pushJoin ', ', rules.map (rule) -> generateRule rule

###
Convert a right-recursive tree to a left-recursive tree.

(node1 (node2 (node3 node4))) => (((node1 node2) node3) node4)

type: type                  type: type
left: node1                 left:
right:                        type: type
  type: type                  left:
  left: node2        =>         type: type
  right:                        left: node1
    type: type                  right: node2
    left: node3               right: node3
    right: node4            right: node4

###
makeTreeLeftRecursive = (node, type, left, right, fifo) ->
  if fifo?
    flipped = type: type
    if node.type is type
      fifo.push node[left]
      flipped[left] = makeTreeLeftRecursive node[right], type, left, right, fifo
      flipped[right] = fifo.shift()
    else
      flipped[left] = fifo.shift()
      flipped[right] = fifo.shift()
      fifo.push node
    flipped
  else
    makeTreeLeftRecursive node[right], type, left, right, [node[left]]

pushJoin = (join, array) ->
  ret = []
  array.forEach (item, index) ->
    return unless item?
    ret.push join if index > 0
    if item instanceof Array
      push.apply ret, item
    else
      ret.push item
  ret

stringify = (value) ->
  "'#{jsStringEscape value}'"
